A polyfill for [`Intl.Segmenter`](https://tc39.es/proposal-intl-segmenter).

[![npm Version](https://img.shields.io/npm/v/@formatjs/intl-segmenter.svg?style=flat-square)](https://www.npmjs.org/package/@formatjs/intl-segmenter)
![size](https://badgen.net/bundlephobia/minzip/@formatjs/intl-segmenter)

## ECMA-402 Spec Compliance

This package is **fully compliant** with the ECMA-402 specification for `Intl.Segmenter`.

### Specification Details

- **TC39 Proposal**: [Intl.Segmenter](https://github.com/tc39/proposal-intl-segmenter)
- **Stage**: Stage 4 (Finalized)
- **Spec**: [ECMA-402 Intl.Segmenter](https://tc39.es/ecma402/#segmenter-objects)

### âœ… Implemented Features

#### Core Methods

- **`segment(string)`** - Returns an iterable `Segments` object for the string
- **`resolvedOptions()`** - Returns resolved options
- **`supportedLocalesOf(locales)`** - Returns supported locales

#### Granularity Options

All 3 segmentation granularities are supported:

- **`'grapheme'`** - Grapheme cluster boundaries (user-perceived characters)
  - Handles combining marks, emoji, etc.
  - Example: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦" is one grapheme
- **`'word'`** - Word boundaries with word/punctuation classification
  - Identifies words, spaces, punctuation
  - Provides `isWordLike` property
- **`'sentence'`** - Sentence boundaries
  - Handles abbreviations, numbers, quotes
  - Locale-aware sentence breaks

#### Segments Object

The `Segments` object returned by `segment()` is:

- **Iterable** - Can be used with `for...of` loops
- **Array-like** - Supports indexed access and `containing(index)` method

#### Segment Object Properties

Each segment has:

- **`segment`** - The text of the segment
- **`index`** - Start index in the original string
- **`input`** - The original input string
- **`isWordLike`** - (word granularity only) Whether segment is a word

### Example Usage

#### Global import

```js
import '@formatjs/intl-segmenter/polyfill.js'

// Grapheme segmentation (user-perceived characters)
const graphemeSegmenter = new Intl.Segmenter('en', {granularity: 'grapheme'})
const graphemes = [...graphemeSegmenter.segment('HelloğŸ‘‹')]
// [
//   {segment: 'H', index: 0, input: 'HelloğŸ‘‹'},
//   {segment: 'e', index: 1, input: 'HelloğŸ‘‹'},
//   {segment: 'l', index: 2, input: 'HelloğŸ‘‹'},
//   {segment: 'l', index: 3, input: 'HelloğŸ‘‹'},
//   {segment: 'o', index: 4, input: 'HelloğŸ‘‹'},
//   {segment: 'ğŸ‘‹', index: 5, input: 'HelloğŸ‘‹'}  // Emoji as one grapheme
// ]

// Word segmentation
const wordSegmenter = new Intl.Segmenter('en', {granularity: 'word'})
const words = [...wordSegmenter.segment('Hello, world!')]
// [
//   {segment: 'Hello', index: 0, isWordLike: true},
//   {segment: ',', index: 5, isWordLike: false},
//   {segment: ' ', index: 6, isWordLike: false},
//   {segment: 'world', index: 7, isWordLike: true},
//   {segment: '!', index: 12, isWordLike: false}
// ]

// Filter to only word-like segments
const onlyWords = words.filter(s => s.isWordLike)
// [{segment: 'Hello', ...}, {segment: 'world', ...}]

// Sentence segmentation
const sentenceSegmenter = new Intl.Segmenter('en', {granularity: 'sentence'})
const sentences = [
  ...sentenceSegmenter.segment('Hello! How are you? I am fine.'),
]
// [
//   {segment: 'Hello! ', index: 0, input: '...'},
//   {segment: 'How are you? ', index: 7, input: '...'},
//   {segment: 'I am fine.', index: 20, input: '...'}
// ]

// containing() method - find segment at specific index
const segments = wordSegmenter.segment('Hello, world!')
segments.containing(7)
// {segment: 'world', index: 7, isWordLike: true}

// Locale-aware segmentation
const thaiSegmenter = new Intl.Segmenter('th', {granularity: 'word'})
const thaiWords = [...thaiSegmenter.segment('à¸ªà¸§à¸±à¸ªà¸”à¸µà¸„à¸£à¸±à¸š')]
// Correctly segments Thai text without spaces

// Complex emoji handling
const emojiSegmenter = new Intl.Segmenter('en', {granularity: 'grapheme'})
const emojis = [...emojiSegmenter.segment('ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿')]
// [
//   {segment: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦', index: 0},  // Family emoji (ZWJ sequence)
//   {segment: 'ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿', index: ...}   // Scotland flag
// ]
```

<Admonition type="info">
    The global import does not include TypeScript type declarations.
    For TypeScript projects, we recommend using ES module imports instead.

    If you choose to use the global import, in order to prevent type errors, you must manually include the corresponding type declaration files (.d.ts) in your project.

</Admonition>

#### ES Modules

```js
import {Segmenter} from '@formatjs/intl-segmenter'

// Grapheme segmentation (user-perceived characters)
const graphemeSegmenter = new Segmenter('en', {granularity: 'grapheme'})
const graphemes = [...graphemeSegmenter.segment('HelloğŸ‘‹')]
```

### Use Cases

- **Character counting**: Get accurate character count including complex emoji
- **Word counting**: Count words across different scripts and languages
- **Text truncation**: Safely truncate at grapheme boundaries
- **Syntax highlighting**: Break code into word segments
- **Search indexing**: Segment text for full-text search
- **Text analysis**: Analyze sentence structure

## Installation

<Tabs
groupId="npm"
defaultValue="npm"
values={[
{label: 'npm', value: 'npm'},
{label: 'yarn', value: 'yarn'},
{label: 'pnpm', value: 'pnpm'},
]}>
<TabItem value="npm">

```sh
npm i @formatjs/intl-segmenter
```

</TabItem>
<TabItem value="yarn">

```sh
yarn add @formatjs/intl-segmenter
```

</TabItem>
<TabItem value="pnpm">

```sh
pnpm add @formatjs/intl-segmenter
```

</TabItem>
</Tabs>

## Features

Everything in [intl-segmenter proposal](https://tc39.es/proposal-intl-segmenter)

## Usage

### Simple

```tsx
import '@formatjs/intl-segmenter/polyfill.js'
```

### Dynamic import + capability detection

```tsx
async function polyfill(locale: string) {
  if (shouldPolyfill()) {
    await import('@formatjs/intl-segmenter/polyfill-force.js')
  }
}
```
