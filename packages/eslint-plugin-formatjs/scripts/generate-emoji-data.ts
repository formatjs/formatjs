/**
 * Generate emoji version data from Unicode emoji-data.txt
 *
 * Parses emoji-data.txt file to create version ranges
 * of emoji codepoints to their Unicode version numbers.
 */

import {outputFileSync} from 'fs-extra/esm'
import minimist, {type ParsedArgs} from 'minimist'
import {readFileSync} from 'fs'

interface EmojiRange {
  start: number // Codepoint as decimal
  end: number // Codepoint as decimal (same as start for single codepoint)
  version: string
  name: string
}

/**
 * Parse emoji-data.txt and extract emoji ranges with versions
 */
function parseEmojiData(content: string): EmojiRange[] {
  const ranges: EmojiRange[] = []
  const lines = content.split('\n')

  for (const line of lines) {
    // Skip comments and empty lines
    if (!line.trim() || line.startsWith('#')) {
      continue
    }

    // Format: codepoint(s) ; property # E<version> [count] (emoji) name
    // Example: 00A9          ; Emoji                # E0.6   [1] (Â©ï¸)       copyright
    // Example: 1F600..1F64F  ; Emoji                # E1.0  [80] (ðŸ˜€..ðŸ™)
    const match = line.match(
      /^([0-9A-F]+(?:\.\.[0-9A-F]+)?)\s*;\s*Emoji\s*#\s*E(\S+)\s+\[(\d+)\]\s+\((.+?)\)\s+(.+)$/
    )
    if (!match) {
      continue
    }

    const [, codepointRange, version, , , name] = match

    // Parse range or single codepoint
    let start: number
    let end: number

    if (codepointRange.includes('..')) {
      const [startHex, endHex] = codepointRange.split('..')
      start = parseInt(startHex, 16)
      end = parseInt(endHex, 16)
    } else {
      start = end = parseInt(codepointRange, 16)
    }

    ranges.push({
      start,
      end,
      version: version.trim(),
      name: name.trim(),
    })
  }

  return ranges
}

/**
 * Generate TypeScript code with emoji version ranges
 */
function generateTypeScript(ranges: EmojiRange[]): string {
  // Collect all unique versions and sort them
  const versions = Array.from(new Set(ranges.map(r => r.version))).sort(
    (a, b) => {
      return parseFloat(a) - parseFloat(b)
    }
  )

  // Group ranges by version
  const versionGroups = new Map<string, EmojiRange[]>()
  for (const range of ranges) {
    if (!versionGroups.has(range.version)) {
      versionGroups.set(range.version, [])
    }
    versionGroups.get(range.version)!.push(range)
  }

  let output = `/**
 * Auto-generated emoji version data from Unicode emoji-data.txt
 * DO NOT EDIT MANUALLY - Generated by scripts/generate-emoji-data.ts
 *
 * Unicode Version: 17.0.0
 * Ranges: ${ranges.length} emoji codepoint ranges
 */

export type EmojiVersion =
${versions.map(v => `  | '${v}'`).join('\n')}

export const EMOJI_VERSIONS: EmojiVersion[] = [
${versions.map(v => `  '${v}',`).join('\n')}
]

export interface EmojiRange {
  /** Start codepoint (decimal) */
  start: number
  /** End codepoint (decimal), same as start for single codepoint */
  end: number
  /** Unicode emoji version */
  version: EmojiVersion
  /** Description */
  name: string
}

/**
 * Emoji codepoint ranges with their Unicode versions
 * Total ranges: ${ranges.length}
 *
 * To check if a codepoint belongs to a version, iterate through ranges
 * and check if codepoint >= start && codepoint <= end
 */
export const EMOJI_RANGES: readonly EmojiRange[] = [
`

  // Add ranges grouped by version
  for (const version of versions) {
    const versionRanges = versionGroups.get(version) || []
    if (versionRanges.length === 0) continue

    output += `  // Version ${version} (${versionRanges.length} ranges)\n`

    for (const range of versionRanges) {
      const nameEscaped = range.name.replace(/'/g, "\\'")
      output += `  {start: 0x${range.start.toString(16).toUpperCase()}, end: 0x${range.end.toString(16).toUpperCase()}, version: '${version}', name: '${nameEscaped}'},\n`
    }

    output += '\n'
  }

  output += `] as const\n`

  return output
}

interface Args extends ParsedArgs {
  out: string
  emojiDataPath: string
}

/**
 * Main function
 */
function main({out, emojiDataPath}: Args): void {
  console.log(`Reading emoji-data.txt from ${emojiDataPath}...`)

  const content = readFileSync(emojiDataPath, 'utf-8')

  console.log('Parsing emoji data...')
  const entries = parseEmojiData(content)
  console.log(`Found ${entries.length} emoji with Emoji property`)

  console.log('Generating TypeScript code...')
  const tsCode = generateTypeScript(entries)

  outputFileSync(out, tsCode, 'utf-8')
}

main(minimist<Args>(process.argv.slice(2)))
