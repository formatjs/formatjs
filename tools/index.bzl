"Custom macro"

load("@aspect_bazel_lib//lib:copy_to_bin.bzl", "copy_to_bin")
load("@aspect_bazel_lib//lib:write_source_files.bzl", "write_source_files")
load("@aspect_rules_js//js:defs.bzl", "js_binary", "js_library", "js_run_binary")
load("@aspect_rules_ts//ts:defs.bzl", "ts_project")
load("//tools:tsconfig.bzl", "BASE_TSCONFIG", "ESNEXT_TSCONFIG")

def ts_compile_node(name, srcs, deps = [], data = [], visibility = None):
    """Compile TS with prefilled args, specifically for Node tooling.

    Args:
        name: target name
        srcs: src files
        deps: deps
        data: add data deps like internal transitive deps
        visibility: visibility
    """
    deps = deps + ["//:node_modules/tslib"]

    ts_project(
        name = "%s-esm-esnext" % name,
        srcs = srcs,
        declaration = True,
        tsconfig = ESNEXT_TSCONFIG,
        resolve_json_module = True,
        deps = deps,
    )

    js_library(
        name = name,
        srcs = [":%s-esm-esnext" % name, "package.json"],
        data = data,
        visibility = visibility,
    )

def ts_compile(name, srcs, deps = [], skip_esm = True, skip_esm_esnext = True, visibility = None):
    """Compile TS with prefilled args.

    Args:
        name: target name
        srcs: src files
        deps: deps
        skip_esm: skip building ESM bundle
        skip_esm_esnext: skip building the ESM ESNext bundle
        visibility: visibility
    """
    deps = deps + ["//:node_modules/tslib"]
    if not skip_esm:
        ts_project(
            name = "%s-esm" % name,
            srcs = srcs,
            declaration = True,
            tsconfig = BASE_TSCONFIG,
            resolve_json_module = True,
            deps = deps,
        )
    if not skip_esm_esnext:
        ts_project(
            name = "%s-esm-esnext" % name,
            srcs = srcs,
            declaration = True,
            out_dir = "lib_esnext",
            tsconfig = ESNEXT_TSCONFIG,
            resolve_json_module = True,
            deps = deps,
        )

    js_library(
        name = name,
        srcs = ([":%s-esm" % name] if not skip_esm else []) + ["package.json"],
        visibility = visibility,
    )

def ts_binary(name, data = [], **kwargs):
    """Create a TS binary with prefilled args.

    Args:
        name: target name
        data: data files or dependencies
        **kwargs: additional arguments passed to js_binary
    """
    js_binary(
        name = name,
        data = data + [
            "//:node_modules/tsx",
        ],
        node_options = [
            "--import",
            "tsx",
        ],
        **kwargs
    )

def ts_run_binary(name, entry_point = None, args = [], tool = None, chdir = None, srcs = [], outs = [], out_dirs = [], **kwargs):
    """Runs a TypeScript binary, optionally creating the tool if not provided.

    Args:
        name: target name
        entry_point: entry point script for the binary
        args: arguments to pass to the binary
        tool: tool binary label (optional)
        chdir: working directory to run the binary in (optional)
        srcs: source files required by the binary
        outs: output files generated by the binary
        out_dirs: output directories generated by the binary
        **kwargs: additional arguments passed to js_run_binary
    """
    if not tool and not entry_point:
        fail("Either tool or entry_point must be provided to ts_run_binary")
    if not tool:
        ts_binary(
            name = "%s_tool" % name,
            entry_point = entry_point,
            chdir = chdir,
        )
    js_run_binary(
        name = name,
        tool = tool if tool else ":%s_tool" % name,
        chdir = chdir,
        srcs = srcs,
        outs = outs,
        out_dirs = out_dirs,
        args = args,
        **kwargs
    )

def generate_src_file(name, src, entry_point = None, tool = None, chdir = None, args = [], data = [], visibility = []):
    """Generate a source file.

    Args:
        name: target name
        args: args to generate src file binary
        data: dependent data labels
        src: src file to generate
        entry_point: generation script entry point
        visibility: target visibility
        chdir: whether to chdir to another dir
        tool: tool binary label
    """
    file_ext = src[src.rindex(".") + 1:]
    tmp_filename = "%s.tmp.%s" % (name, file_ext)
    ts_run_binary(
        name = tmp_filename[:tmp_filename.rindex(".")],
        outs = [tmp_filename],
        entry_point = entry_point,
        tool = tool,
        # NOTE: assumes that all scripts called here accept `--out` and
        # also uses fs-extra + minimist.
        args = args + [
            "--out",
            "$(rootpath %s)" % tmp_filename,
        ],
        chdir = chdir,
        srcs = data + [
            "//:node_modules/fs-extra",
            "//:node_modules/minimist",
        ],
    )

    files = {}
    files[src] = tmp_filename

    write_source_files(
        name = name,
        files = files,
        visibility = visibility + [
            "//:__pkg__",
        ],
        suggested_update_target = "//%s:%s" % (native.package_name(), tmp_filename[:tmp_filename.rindex(".")]),
    )

def is_internal_dep(s):
    return s.startswith("//:node_modules/@formatjs") or s in [
        "//:node_modules/babel-plugin-formatjs",
        "//:node_modules/eslint-plugin-formatjs",
        "//:node_modules/intl-messageformat",
        "//:node_modules/react-intl",
        "//:node_modules/vue-intl",
    ]

def package_json_test(name, packageJson = "package.json", deps = []):
    copy_to_bin(
        name = "package",
        srcs = ["package.json"],
        visibility = ["//visibility:public"],
    )

    internal_deps = [
        s
        for s in deps
        if is_internal_dep(s)
    ]

    external_deps = [s for s in deps if s not in internal_deps]

    # TODO: fix this
    # ts_node_bin.ts_node_test(
    #     name = name,
    #     args = [
    #                "--transpile-only",
    #                "$(location //tools:check-package-json)",
    #                "--rootPackageJson",
    #                "$(location //:package)",
    #                "--packageJson",
    #                "$(location %s)" % packageJson,
    #            ] +
    #            (["--externalDep %s" % n for n in external_deps] if external_deps else []) +
    #            (["--internalDep %s" % d.split("//:node_modules/")[1] for d in internal_deps] if internal_deps else []),
    #     data = internal_deps + [
    #         packageJson,
    #         "//tools:check-package-json",
    #         "//:package",
    #         "//:tsconfig",
    #         "//:node_modules/@types/fs-extra",
    #         "//:node_modules/@types/minimist",
    #         "//:node_modules/fs-extra",
    #         "//:node_modules/json-stable-stringify",
    #
    #         "//:node_modules/minimist",
    #         "//:node_modules/lodash",
    #         "//:node_modules/@types/lodash",
    #         "//:node_modules/unidiff",
    #         "//:node_modules/tslib",
    #         "//:tsconfig.node",
    #     ],
    # )
